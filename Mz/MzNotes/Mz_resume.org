#+TITLE: Resume
#+DATE: <2018-02-24 六>

* Linux内核开发工程师

** Linux kernel 架构部分

*** linux进程管理
    
    进程的概念:
    #+BEGIN_EXAMPLE
    进程是处于执行期的程序和资源的总称(目标代码存放在某种存储介质上)
    进程不仅仅局限于代码段,还有程序使用的相关资源.
    如: 打开的文件,挂起的信号,内核内部数据,处理器状态,一个或者多个具有内存映射的地址空间和一个或多个执行线程,还包括用来存放全局变量的数据段等内容.
    实际上进程就是正在执行的代码的实时结果.
    #+END_EXAMPLE

    线程的概念: 
    #+BEGIN_EXAMPLE
    就是执行线程,进程中活动的对象!
    每个线程有自己独立的程序计数器,进程栈和一组程序寄存器.
    内核的调度对象是线程,不是进程!
    在linux中线程只不过是比较特殊一点的进程而已.
    #+END_EXAMPLE

    内核提供的虚拟机制:
    #+BEGIN_EXAMPLE
    1. 虚拟处理器
    : 假设每个进程独享处理器.
    2. 虚拟内存
    : 假设每个进程拥有整个系统的所有内存资源.
    #+END_EXAMPLE

    fork派生进程:
    实际上是clone系统调用实现的.

    exit退出进程:
    实际上是释放fork出来进程的资源,但是并不撤销进程描述符等包含返回给父进程的资源.

    wait有父进程调用:
    实际就是获得子进程的返回信息,并释放子进程剩余的所有资源.

    进程描述符和结构: 包含整个进程信息的task_struct, 比较大

    内核把进程的列表存放在任务队列中,是双向列表实现的.(当然有的并不一定使用链表实现,因为需要更快!)
    不过所有进程应该都被关联到一个大的队列中,就是双向链表中,这样也是统一的.


    linux如何分配进程描述符:
    通过内存管理的slab机制完成,这样能够达到对象复用和缓存着色.

    进程描述符的存放:
    尽量最快的位置,寄存器或者栈的固定位置.
    对于x86来说,在栈的尾部创建一个指向task_strcut的结构就可以完成快速索引,有寄存器更好.
    current宏更具架构实现可能不一样.并且只有在进程上下文中使用才有意义.

    进程的状态:
    进程的5状态值,也必须属于其中的一种
    1. TASK_RUNNING 运行态 (包括正在运行和就绪的进程)
    2. TASK_INTERRUPTIBLE 可中断的睡眠态
    3. TASK_UNINTERRUPTIBLE 不可中断的睡眠态
    4. __TASK_TRACED 被其他进程跟踪的进程,如ptrace
    5. __TASK_STOPPED 进程停止执行

       
    使用特定的宏或函数完成进程状态的改变,不能直接修改.
    
    进程上下文:
    #+BEGIN_EXAMPLE
    简述:
    需要知道的是,内核就是一个大的回调函数,提供应有的机制!
    可执行程序是进程的重要组成部分,这些代码从一个可执行文件载入到进程的地址空间中执行.
    一般程序在用户空间中执行,当一个程序执行了系统调用或者触发了某个异常,它就会陷入内核.
    此时我们称内核代表进程执行并处于进程上下文.
    内核完成相应工作再返回用户空间继续执行.
    #+END_EXAMPLE

       
    进程家族树:
    #+BEGIN_EXAMPLE
    所有的进程都是PID为1的init进程的后代.
    进程之间是继承关系.
    init进程读取初始化脚本,执行相关的进程,完成系统的初始化.
    init进程的描述符是由init_task静态分配的.
    可以通过遍历的方法访问所有进程.
    #+END_EXAMPLE


    进程的创建:
    #+BEGIN_EXAMPLE
    进程的创建分为两步:
    1. fork
    写时拷贝父进程的内容.(无需复制没有用的内容而浪费资源)
    一般的区别是PID,PPID,某些资源和统计量(如,挂起的信号就没有必要继承,但是信号处理函数还是可以继承的)
    2. exec
    负责从存储设备读取可执行文件到进程地址空间(当然,之前肯定是分配了进程地址空间的),并开始运行.
    #+END_EXAMPLE

    fork的流程:
    vfork的流程:

    线程在linux中的实现:
    #+BEGIN_EXAMPLE
    这里说说线程之间共享那些东西
    共享进程地址空间.
    共享打开的文件和其他的一些资源(这些资源靠通过传入clone的参数来确定)
    linux内核的线程和进程都用一种结构表示.
    #+END_EXAMPLE

    创建线程:
    #+BEGIN_EXAMPLE
    创建线程和创建进程是类似的,只不过调用clone时候,传递的参数不同而已.
    如:
    clone(CLONE_FS | CLONE_FILES | CLONE_VM | CLONE_SIGHAND, 0);
    就表示共享主线程的文件系统,打开的文件,地址空间和信号处理程序.

    需要知道的是,线程和进程,都是进程衍生的,都差不多,只不过线程之间没有父子关系,如果你认为有也是可以的,一个是主线程,其他的是衍生的副线程.

    具体的标志位在<linux/sched.h>
    #+END_EXAMPLE
    
    内核线程:
    #+BEGIN_EXAMPLE
    内核线程和普通的进程之间的区别:
    内核线程没有独立的地址空间！实际上指向ｍｍ的指针被设置为NULL.
    只能在内核空间中执行.

    其他的和普通进程一样,可以被调度也可以被抢占.
    创建内核线程可以使用标准接口,但是最后也是调用clone函数.
    #+END_EXAMPLE

    进程终结:
    #+BEGIN_EXAMPLE
    可以显示的调用exit()终结,或者隐式的调用exit()终结.
    do_exit()处理主要细节.
    
    #+END_EXAMPLE

    删除进程描述符:
    #+BEGIN_EXAMPLE
    进程退出后,还是会有进程描述符剩下的,这个需要父进程来完成回收.
    wait4()由父进程调用来完成回收.
    #+END_EXAMPLE

    孤儿进程的问题:
    #+BEGIN_EXAMPLE
    孤儿就是由于自己的父进程挂了,自己没有指定的父进程了
    当然也是可以有其他的选择.就是在当前的线程组内(死掉的父进程的线程组内),找一个父亲.如果不行再指定init为自己的父进程;
    #+END_EXAMPLE

*** linux调度子系统

    linux的进程调度历史
    从大O算法到公平调度

    linux进程调度策略:
    #+BEGIN_EXAMPLE
    调度器的策略需要动态的调整的,也就是采用不同的算法架构.

    正常的进程分为: IO密集型和处理器密集型,也有两个都有的.这就需要抉择.
    #+END_EXAMPLE

    进程优先级:
    #+BEGIN_EXAMPLE
    普通进程是有优先级的,也是nice值来决定的,越小优先值越高.-20~+19
    还有一种范围就是实时优先级,对于linux来说,实时进程的优先级都比普通的高.(虽然linux主板本并不支持实时系统,只是近似而已) 0~99 越大越高
    #+END_EXAMPLE

    时间片:
    #+BEGIN_EXAMPLE
    这个也是一个策略需要考虑的内容.
    但是时间片配合优先级的调度并不公平.
    需要知道的是,时间片是内容根据所有进程来完成的规划.
    #+END_EXAMPLE

    linux的调度算法
    
    调度器类
    很明显,调度器是需要根据进程的类型来完成动态选择的,也就是内核可以选择多种调度器.
    这样,需要一个类的概念,然后以模块的形式完成,使用的时候根据不同的需求实例化.

    unix系统的调度程序存在一些问题,这也是老版本的调度器的问题.需要讨论!!!

    公平调度CFS
    就是根据cpu的负载来完成调度和分配cpu运行时间片,优先级就是权重.

    linux调度的实现:
    重点关注的方面是
    1. 时间记账功能
    2. 进程选择
    3. 调度器的入口 就是schedule()
    4. 睡眠和唤醒 睡眠是等待队列的实现, 唤醒就是wake_up()指定的等待队列

    抢占和进程上下文的切换
    主要就是context_switch()
    完成的主要工作有两个:
    1. switch_mm从一个进程的地址空间,切换到另一个.
    2. switch_to负责将处理器的状态从一个进程切换到另一个进程.
    3. need_resched标志是一个比较重要的角色,表示是否需要重新执行一次调度!
    4. 每一个进程都含有一个need_resched标志成员.


    用户抢占:
    内核在返回用户空间时,会判断need_resched标志,如果为1,会导致schedule的调用,此时发生用户抢占.
    发生的时间点为:
    1. 系统调用返回用户空间时.
    2. 从中断处理程序返回用户空间的时候.
    内核抢占:
    只要进程环境是安全的,就是没有锁,那么就可以随时抢占.
    发生的时间点为:
    1. 中断处理程序返回内核空间的时候
    2. 内核代码再一次具有抢占性的时候
    3. 如果内核中的代码显示的调用schedule
    4. 如果内核中的任务阻塞,隐式的调用schedule

       
    linux的实时调度策略:
    提供两种调度策略,SCHED_FIFO和SCHED_RR
    
    内核不为实时进程设置动态优先级.静态优先级是100,他们比普通进程的优先级都高,他们之间也是有优先级的,高的抢占低的.
    SCHED_FIFO 就是先来先执行.如果自己不执行schedule或者没有更好优先级的实时进程抢占,那它会一直运行
    SCHED_RR 就是轮流的执行实时进程,它有时间片的概念,需要知道的是,它是耗尽时间片就不再执行了,但是也不可以被低级别的SCHED_FIFO抢占.
    当时间片耗尽的时候,同一级别的其他进程轮流执行.高级别的进程当然可以抢占.
    
    与调度相关的系统调用,这个需要练习的时候使用.

*** linux内存管理

*** linux内核同步方法

*** linux内核系统调用
    
    系统调用号
    : 每个系统调用都有固定的编码
    系统调用的性能
    : 由于陷入和工作空间的切换,需要很大的代价,所以如果使用系统调用开发应用,应该借助C标准库完成.

    系统调用处理程序
    #+BEGIN_EXAMPLE
    系统调用需要的是陷入内核,并且如果陷入的话需要通知内核,这是靠软中断实现的.这个和硬件的中断陷入内核是不同的.
    
    也就是,通知内核是靠软中断实现的: 应用程序触发一个异常,然后陷入内核,到达固定的系统调用处理程序的入口.

    该软中断的中断号是固定的,如x86是128, 触发的指令是int $0x80 , system_call 汇编代码

    然后通过系统调用号,指定系统调用.

    系统调用的参数传递: 参数多的时候使用一个寄存器存多参的指针,少的话,直接就使用固定的寄存器完成.
    #+END_EXAMPLE

    系统调用的实现:
    #+BEGIN_EXAMPLE
    这个很简单,就是注册一个系统调用号,然后写添加到调用表,就可以了.
    #+END_EXAMPLE

    参数验证:
    #+BEGIN_EXAMPLE
    一般内核和用户空间的交互是需要安全的函数来处理传递参数的.
    #+END_EXAMPLE

    系统调用的进程上下文:
    #+BEGIN_EXAMPLE
    这个系统调用是关联进程的,并且可以睡眠,也可以被抢占.
    所以系统调用需要是安全可重入的!
    #+END_EXAMPLE

    系统调用实现的最后步骤:
    #+BEGIN_EXAMPLE
    在系统调用表最后加入表项.
    对于所有的体系结构,都要在<asm/unistd.h>中定义调用号.
    系统调用必须编译进内核镜像,不能编译成模块.
    #+END_EXAMPLE

    从用户空间访问系统调用:
    #+BEGIN_EXAMPLE
    自定义的系统调用,没有C标准库的支持,只能使用通用的方法完成调用.
    
    如:
    long open(const char * filename, int flags, int mode)

    没有库支持的话:
    #define NR_open 5
    __syscall3(long, open, const char*, filename, int, flags, int, mode)
    #+END_EXAMPLE

    一般不需要实现系统调用,内核的简洁高效是很好的,系统调用一般不用自己实现.

*** linux内核中断和中断处理

    中断一般就是cpu给相应硬件来使用的,一般用硬中断表示,可以随时到来.

    硬中断并不考虑硬件设备和处理器的时钟同步.也可叫异步中断.

    中断控制器处理cpu外围的硬件中断.

    中断信号线是有静态和动态的,一般在总线上使用的,都是动态分配的.

    异常与中断不同,产生的时候必须要与处理器的时钟同步,通常叫做同步中断或者软中断.

    内核对于硬中断和软中断的处理行为类似,也就归为一类.

    一般中断处理程序是硬件驱动程序的一部分,也是重要的部分,用来完成突发事件.

    中断处理程序不属于任何的进程,是中断上下文.

    鉴于中断的效率问题,有了中断的上半部和下半部.
    
    通过内核的标准接口注册中断处理程序,当然撤销中断处理程序也是通过固定的接口.

    中断处理程序并不一定要可重入,应为当中断发生的时候,硬件就会自动屏蔽该中断.

    linux内核有一个机制是共享中断处理程序.
    
    需要解释的一些问题:
    #+BEGIN_EXAMPLE
    首先,一条中断线可以对应多个中断处理程序,即多个中断处理程序可以共享一条中断线,只要能够区分就可以了.
    还有,一个硬件设备可能有多条中断线,也就是可能一个设备对应多个中断,虽然在内核中不是以设备为单位的.
    一般linux内核允许用户按照中断线来注册中断处理程序.
    规则之中中断线是固定的,对应一种中断!
    #+END_EXAMPLE

    中断上下文中是比较严格的,不可以睡眠或调度!

    中断处理机制的实现流程:
    #+BEGIN_EXAMPLE
    1. 硬件产生一个中断.
    2. 中断控制器接受并过滤出该中断给cpu
    3. cpu接受到中断然后中断内核.
    4. 调用do_IRQ()判断中断线是否有对应注册的中断处理程序.
    5. 如果有,那么就将所有注册的中断挨个执行.执行完成后,返回内核中断之前运行.
    6. 如果没有就返回内核中断之前的代码继续运行.
    #+END_EXAMPLE

    linux内核必须有控制中断的能力.

    禁止和激活中断,这个任务其实就是控制中断控制器就可以实现,不用控制具体的硬件设备.

    禁止指定的中断线,这就是禁止中断控制器的某一位的编程.

    同样需要能够查询当前时间点的中断状态.

*** linux下半部和推后执行的工作

    下半部也是在中断上下文中,需要遵守中断上下文的规则.

    了解linux内核提供的下半部机制后,需要知道在什么条件下选择哪个下半部:
    #+BEGIN_EXAMPLE
    软中断(和前面的同步中断不同概念):
    使用软中断的原因主要是扩展性,需要扩展到多个处理器时需要考虑使用这个.
    同一个中断是只能在一个处理器上运行的.
    但是,同一个种类的软中断可以在不同的处理器上运行.只需要对共享数据加以照顾就可以了.
    它的效率很高.

    tasklet机制:
    这个机制是由软中断衍生的.
    如果代码的多线处理并不重要,那就使用tasklet,接口很简单,并且同种类型的tasklet不能同时运行,在同多个cpu上也不行.
    
    工作队列机制:
    采用和上面两个完全不同的机制,靠内核线程完成操作,可以睡眠调度.

    #+END_EXAMPLE

*** linux内核常用的数据结构

    链表:

    队列:

    映射:

    二叉树:

    常用数据结构的选择:

    算法复杂度的讨论:

*** linux内核定时器和时间管理

*** linux内核虚拟文件系统

*** linux内核的块IO层

*** linux进程地址空间

*** linux页高速缓存和页回写

*** linux内核调试

*** linux设备与模块

*** linux可移植性

* Linux驱动开发工程师

** 基于linux内核

* Linux应用开发工程师(包括网络开发)

** 基于linux的C/C++应用开发部分

