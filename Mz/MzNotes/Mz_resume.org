#+TITLE: Resume
#+DATE: <2018-02-24 六>

* Linux内核开发工程师

** Linux kernel 架构部分

*** linux进程管理
    
    进程的概念:
    #+BEGIN_EXAMPLE
    进程是处于执行期的程序和资源的总称(目标代码存放在某种存储介质上)
    进程不仅仅局限于代码段,还有程序使用的相关资源.
    如: 打开的文件,挂起的信号,内核内部数据,处理器状态,一个或者多个具有内存映射的地址空间和一个或多个执行线程,还包括用来存放全局变量的数据段等内容.
    实际上进程就是正在执行的代码的实时结果.
    #+END_EXAMPLE

    线程的概念: 
    #+BEGIN_EXAMPLE
    就是执行线程,进程中活动的对象!
    每个线程有自己独立的程序计数器,进程栈和一组程序寄存器.
    内核的调度对象是线程,不是进程!
    在linux中线程只不过是比较特殊一点的进程而已.
    #+END_EXAMPLE

    内核提供的虚拟机制:
    #+BEGIN_EXAMPLE
    1. 虚拟处理器
    : 假设每个进程独享处理器.
    2. 虚拟内存
    : 假设每个进程拥有整个系统的所有内存资源.
    #+END_EXAMPLE

    fork派生进程:
    实际上是clone系统调用实现的.

    exit退出进程:
    实际上是释放fork出来进程的资源,但是并不撤销进程描述符等包含返回给父进程的资源.

    wait有父进程调用:
    实际就是获得子进程的返回信息,并释放子进程剩余的所有资源.

    进程描述符和结构: 包含整个进程信息的task_struct, 比较大

    内核把进程的列表存放在任务队列中,是双向列表实现的.(当然有的并不一定使用链表实现,因为需要更快!)
    不过所有进程应该都被关联到一个大的队列中,就是双向链表中,这样也是统一的.


    linux如何分配进程描述符:
    通过内存管理的slab机制完成,这样能够达到对象复用和缓存着色.

    进程描述符的存放:
    尽量最快的位置,寄存器或者栈的固定位置.
    对于x86来说,在栈的尾部创建一个指向task_strcut的结构就可以完成快速索引,有寄存器更好.
    current宏更具架构实现可能不一样.并且只有在进程上下文中使用才有意义.

    进程的状态:
    进程的5状态值,也必须属于其中的一种
    1. TASK_RUNNING 运行态 (包括正在运行和就绪的进程)
    2. TASK_INTERRUPTIBLE 可中断的睡眠态
    3. TASK_UNINTERRUPTIBLE 不可中断的睡眠态
    4. __TASK_TRACED 被其他进程跟踪的进程,如ptrace
    5. __TASK_STOPPED 进程停止执行

       
    使用特定的宏或函数完成进程状态的改变,不能直接修改.
    
    进程上下文:
    #+BEGIN_EXAMPLE
    简述:
    需要知道的是,内核就是一个大的回调函数,提供应有的机制!
    可执行程序是进程的重要组成部分,这些代码从一个可执行文件载入到进程的地址空间中执行.
    一般程序在用户空间中执行,当一个程序执行了系统调用或者触发了某个异常,它就会陷入内核.
    此时我们称内核代表进程执行并处于进程上下文.
    内核完成相应工作再返回用户空间继续执行.
    #+END_EXAMPLE

       
    进程家族树:
    #+BEGIN_EXAMPLE
    所有的进程都是PID为1的init进程的后代.
    进程之间是继承关系.
    init进程读取初始化脚本,执行相关的进程,完成系统的初始化.
    init进程的描述符是由init_task静态分配的.
    可以通过遍历的方法访问所有进程.
    #+END_EXAMPLE


    进程的创建:
    #+BEGIN_EXAMPLE
    进程的创建分为两步:
    1. fork
    写时拷贝父进程的内容.(无需复制没有用的内容而浪费资源)
    一般的区别是PID,PPID,某些资源和统计量(如,挂起的信号就没有必要继承,但是信号处理函数还是可以继承的)
    2. exec
    负责从存储设备读取可执行文件到进程地址空间(当然,之前肯定是分配了进程地址空间的),并开始运行.
    #+END_EXAMPLE

    fork的流程:
    vfork的流程:

    线程在linux中的实现:
    #+BEGIN_EXAMPLE
    这里说说线程之间共享那些东西
    共享进程地址空间.
    共享打开的文件和其他的一些资源(这些资源靠通过传入clone的参数来确定)
    linux内核的线程和进程都用一种结构表示.
    #+END_EXAMPLE

    创建线程:
    #+BEGIN_EXAMPLE
    创建线程和创建进程是类似的,只不过调用clone时候,传递的参数不同而已.
    如:
    clone(CLONE_FS | CLONE_FILES | CLONE_VM | CLONE_SIGHAND, 0);
    就表示共享主线程的文件系统,打开的文件,地址空间和信号处理程序.

    需要知道的是,线程和进程,都是进程衍生的,都差不多,只不过线程之间没有父子关系,如果你认为有也是可以的,一个是主线程,其他的是衍生的副线程.

    具体的标志位在<linux/sched.h>
    #+END_EXAMPLE
    
    内核线程:
    #+BEGIN_EXAMPLE
    内核线程和普通的进程之间的区别:
    内核线程没有独立的地址空间！实际上指向ｍｍ的指针被设置为NULL.
    只能在内核空间中执行.

    其他的和普通进程一样,可以被调度也可以被抢占.
    创建内核线程可以使用标准接口,但是最后也是调用clone函数.
    #+END_EXAMPLE

    进程终结:
    #+BEGIN_EXAMPLE
    可以显示的调用exit()终结,或者隐式的调用exit()终结.
    do_exit()处理主要细节.
    
    #+END_EXAMPLE

    删除进程描述符:
    #+BEGIN_EXAMPLE
    进程退出后,还是会有进程描述符剩下的,这个需要父进程来完成回收.
    wait4()由父进程调用来完成回收.
    #+END_EXAMPLE

    孤儿进程的问题:
    #+BEGIN_EXAMPLE
    孤儿就是由于自己的父进程挂了,自己没有指定的父进程了
    当然也是可以有其他的选择.就是在当前的线程组内(死掉的父进程的线程组内),找一个父亲.如果不行再指定init为自己的父进程;
    #+END_EXAMPLE

*** linux调度子系统

    linux的进程调度历史
    从大O算法到公平调度

    linux进程调度策略:
    #+BEGIN_EXAMPLE
    调度器的策略需要动态的调整的,也就是采用不同的算法架构.

    正常的进程分为: IO密集型和处理器密集型,也有两个都有的.这就需要抉择.
    #+END_EXAMPLE

    进程优先级:
    #+BEGIN_EXAMPLE
    普通进程是有优先级的,也是nice值来决定的,越小优先值越高.-20~+19
    还有一种范围就是实时优先级,对于linux来说,实时进程的优先级都比普通的高.(虽然linux主板本并不支持实时系统,只是近似而已) 0~99 越大越高
    #+END_EXAMPLE

    时间片:
    #+BEGIN_EXAMPLE
    这个也是一个策略需要考虑的内容.
    但是时间片配合优先级的调度并不公平.
    需要知道的是,时间片是内容根据所有进程来完成的规划.
    #+END_EXAMPLE

    linux的调度算法
    
    调度器类
    很明显,调度器是需要根据进程的类型来完成动态选择的,也就是内核可以选择多种调度器.
    这样,需要一个类的概念,然后以模块的形式完成,使用的时候根据不同的需求实例化.

    unix系统的调度程序存在一些问题,这也是老版本的调度器的问题.需要讨论!!!

    公平调度CFS
    就是根据cpu的负载来完成调度和分配cpu运行时间片,优先级就是权重.

    
    linux调度的实现:
    重点关注的方面是
    1. 时间记账功能
    2. 进程选择
    3. 调度器的入口 就是schedule()
    4. 睡眠和唤醒 睡眠是等待队列的实现, 唤醒就是wake_up()指定的等待队列

    抢占和进程上下文的切换
    主要就是context_switch()
    完成的主要工作有两个:
    1. switch_mm从一个进程的地址空间,切换到另一个.
    2. switch_to负责将处理器的状态从一个进程切换到另一个进程.
    3. need_resched标志是一个比较重要的角色,表示是否需要重新执行一次调度!
    4. 每一个进程都含有一个need_resched标志成员.


    用户抢占:
    内核在返回用户空间时,会判断need_resched标志,如果为1,会导致schedule的调用,此时发生用户抢占.
    发生的时间点为:
    1. 系统调用返回用户空间时.
    2. 从中断处理程序返回用户空间的时候.
    内核抢占:
    只要进程环境是安全的,就是没有锁,那么就可以随时抢占.
    发生的时间点为:
    1. 中断处理程序返回内核空间的时候
    2. 内核代码再一次具有抢占性的时候
    3. 如果内核中的代码显示的调用schedule
    4. 如果内核中的任务阻塞,隐式的调用schedule

       
    linux的实时调度策略:
    提供两种调度策略,SCHED_FIFO和SCHED_RR
    
    内核不为实时进程设置动态优先级.静态优先级是100,他们比普通进程的优先级都高,他们之间也是有优先级的,高的抢占低的.
    SCHED_FIFO 就是先来先执行.如果自己不执行schedule或者没有更好优先级的实时进程抢占,那它会一直运行
    SCHED_RR 就是轮流的执行实时进程,它有时间片的概念,需要知道的是,它是耗尽时间片就不再执行了,但是也不可以被低级别的SCHED_FIFO抢占.
    当时间片耗尽的时候,同一级别的其他进程轮流执行.高级别的进程当然可以抢占.
    
    与调度相关的系统调用,这个需要练习的时候使用.

*** linux内存管理

*** linux内核同步方法

*** linux内核系统调用

*** linux内核中断和中断处理

*** linux内核常用的数据结构

*** linux下半部和推后执行的工作

*** linux内核定时器和时间管理

*** linux内核虚拟文件系统

*** linux内核的块IO层

*** linux进程地址空间

*** linux页高速缓存和页回写

*** linux内核调试

*** linux设备与模块

*** linux可移植性

* Linux驱动开发工程师

** 基于linux

* Linux应用开发工程师(包括网络开发)

** 基于linux的C/C++应用开发部分

