#+TITLE: Linux内核代码之美

: 主要记录linux内核代码中的一些特殊的,漂亮的,巧妙的代码内容.

** D: linux内核中可能常看到while(1)循环,为什么?

*** T: 在linux内核中,while(1)循环一般都是有原因的.

    一般的原因是: 在while参数判断中,无法完成复杂判断,如内核锁,所以常配合break来完成相应的操作.

** D: 访问进程描述符中的成员变量通常比访问其他的普通全局变量快

*** T: 之所以这样原因在于,内核是根据体系结构实现的current宏,并且常常将进程描述符存在告诉缓存中.

    当然,你也可以实现自己的变量在告诉缓存中,不过通常我们不会用到.

** D: linux内核的中断处理程序和系统调用返回的返回路径都是和体系结构相关的

*** T: 也就是说明,内核的陷入和返回都是和体系结构相关的

    linux内核在 _entry.S_ 文件中以汇编实现.

    此文件包含内核入口部分的程序,还包含内核退出部分的程序.

** D: linux内核中的抢占关键点

*** T: 抢占的关键点在于是否当前环境是可以安全的进行抢占的.

    抢占一般分为两种:
    1. 当前的进程主动让出,显示的触发进程抢占,这个时候内核不会考虑安全的因素,它默认你是知道现在的环境是安全的.
    2. 被动抢占是内核自主的调度,安全性检查也是内核自己完成的.

    其实所谓的安全环境,就是内核锁:
    1. 如果有锁,那就是不安全的.
    2. 如果没有锁,抢占就是安全的.

       
    内核抢占和用户抢占有一些区别

    用户抢占发生在:
    1. 从系统调用返回用户空间时.
    2. 从中断处理程序返回用户空间时.

    内核抢占发生在:
    1. 中断处理程序正在执行,且返回内核空间之前.
    2. 内核代码再次具有可抢占性的时候.
    3. 当内核中的任务显示的调用schedule()时候
    4. 当内核中的任务被阻塞的时候(这样会导致调用schedule())

** D: linux内核中的数组很多时候下标都是有意义的

*** T: 一般下标都是按照某一特定顺序来排列的

    有时候数据下标就像键值对中的键一样,表示特殊的意义.




